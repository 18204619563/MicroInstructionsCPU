# MicroInstructionsCPU
Computer composition principle class homework, writing in VHDL, simulating with ModelSimSe10.1a.

从硬件层到汇编层设计方案

标签： 计算机主成原理 VHDL 微程序CPU 

---


## 1. 设计
#### 1.1 整体介绍 

本实验旨在使用硬件设计语言，采用微程序方式实现具有数条指令的控制单元 CU，并针对其功能进行仿真。现行的CPU主要有两种设计，一种是基于组合逻辑的指令系统，这种系统CPU几乎独立的解释每一条指令的执行，设计复杂，硬件结构庞大，相比之下，另一种微程序实现方式就能解决其设计问题，结构简单，易于并行流水。

所谓微指令就是把同时发出的控制信号的有关信息汇集起来形成的。将一条指令分成若干条微指令，按次序执行就可以实现指令的功能。通过这种方式和较合理的设计就可以在很大程度上复用CPU功能，并且较好的实现高级的CPU指令。

### 1.2 系统结构设计
#### 1.2.1 模块的划分
    
   根据微程序CPU中的基本结构按功能划分为 控制存储器，信号总线，累加器寄存器，通用寄存器及通用寄存器指针，零标志寄存器，运算结构。
    
    

 - 存储控制器
    存储控制器使用10K*8bitROM结构实现，由于外部永远与微程序地址指针uPC关联，不用额外使用三态门控制，并且可以设置为异步元件。

 - 信号总线
    CPU的外接信号总线使用三态门信号（STD_LOGIC_VECTOR）实现，CPU中总线控制有并行于CPU逻辑的单独PROCESS管理。

 - 累加器寄存器
    使用内部信号nacc实现。从功能上来说此寄存器是比较常用的寄存器，是沟通CPU外部设备和CPU内部及其他寄存器的桥梁。

 - 通用寄存器及通用寄存器指针
    通用寄存器指针通过控制字使用单独PROCESS异步计算。通用寄存器使用4*8bit存储向量数组实现。

 - 零标志寄存器
    零标志寄存器使用独立信号zy表示，记录nacc的状态，在nacc=“00000000”时为1，其余为0，该寄存器用于零判断和条件跳转。

 - 运算结构
    实例中运算结构利用IEEE.STD_LOGIC_UNSIGNED实现，具体实现了累加器自增，通用寄存器相减等功能。    

    
#### 1.2.2 控制字的设计与划分
    
   综合分析了系统需要的微指令量，选择8bit的微程序控制字，其中前四位为操作控制位，5-6位为地址选择位，由于系统设计通用寄存器和外部总线的调用互斥，故使用同样的两位控制选择。7-8位为微程序指令指针（uPC）控制位，控制uPC的移动（+1，归零，IR变址，条件跳转）。
    
#### 1.2.3 CPU设计原理图

![图5 仿真波形](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/cpu.png?raw=true)

### 1.3 系统辅助模块设计

1. 主存

    本次实验制作的主存为了展示方便在一个模块下做了两种形式的存储结构。前半段模仿ROM存储（查表静态输出），设为程序区，程序写在代码之中，方便调试和展示。后半段模仿RAM存储方式，使用动态寄存器存储（std_logic二维数组），支持存取。
    地址范围（0 - 2^8)。其中0x00-0x7f为程序区（未占满），其余0x80-0xff可存取的数据区域。
    对于辅助功能设计，尽量简化了设计，使用控制总线控制主存的读写，没有设置特殊的读写管脚，使用控制总线的某保留字控制读写。
    
![mem](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/mem.png?raw=true)

2. IO
    IO设计实现了从IO读入功能。系统主要展示的是CPU中控制单元对总线的控制情况，实现对多个总线挂载设备（主存，IO）的合理控制。
    IO端口的设计模拟IO输入行为，当选中IO为输入源是输入固定的IO数据。
    
![io](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/io.png?raw=true)
?
3. 主板总线逻辑
    主要实现总线搭接和提供系统时钟、重置信号。
    总线使用外部信号变量方式实现。
    重置信号在开始20ns后失效，时钟使用延时模拟实现。
    主板总线模块为测试模块。
    
![bus](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/bus.png?raw=true)

## 系统整体框架设计图

## 指令集及微程序集设计

微指令集合

|微地址|	微指令|	操作7-4|	方式3-2|	uPC|
| :---: | :---: | :---: | :---: | :---: |
| 指令default	|
| "0000000000"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++ |
| "0000000001"|	"00010000"|	dbus->IR|	(mem->cpu)->cbus	|++ |
| "0000000010"|	"11110010"|	PC++	|(mem->cpu)->cbus	|IR<<2->uPC |
| "0000000011"|	"00000000"|			
| 指令(00000001)|acc++	|
| "0000000100"|	"00110011"|	ACC++	|(mem->cpu)->cbus	|0|
| "0000000101"|	"00000000"|		
| "0000000110"|	"00000000"|		
| "0000000111"|	"00000000"|		
| 指令(00000010)|acc=[xx] |	
|"0000001000"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++|
|"0000001001"|	"00010000"|	dbus->IR|	(mem->cpu)->cbus	|++|
|"0000001010"|	"01000000"|	IR->ACC|	(mem->cpu)->cbus	|++|
|"0000001011"|	"11110011"|	PC++	|(mem->cpu)->cbus	|0|
|指令(00000011)|acc=io|	|
|"0000001100"|	"00100100"|	null	|(io->cpu)->cbus	|++|
|"0000001101"|	"00010100"|	dbus->IR|	(io->cpu)->cbus	|++|
|"0000001110"|	"01000111"|	IR->ACC|	(io->cpu)->cbus	|0|
|"0000001111"|	"00000000"|			
| 指令(00000100)|acc=mem[xx]	|
|"0000010000"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++|
|"0000010001"|	"01100000"|	dbus->mar|	(mem->cpu)->cbus	|++|
|"0000010010"|	"01010000"|	mar->abus|	(mem->cpu)->cbus	|++|
|"0000010011"|	"00010000"|	dbus->IR|	(mem->cpu)->cbus	|++|
|"0000010100"|	"01000000"|	IR->ACC|	(mem->cpu)->cbus	|++|
|"0000010101"|	"11110011"|	PC++	|(mem->cpu)->cbus	|0|
|"0000010110"|	"00000000"|			
| "0000010111"|	"00000000"|		
| 指令(00000110)|jmp[xx]	|
|"0000011000"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++|
|"0000011001"|	"00010000"|	dbus->IR|	(mem->cpu)->cbus	|++|
|"0000011010"|	"01110011"|	IR->PC|	(mem->cpu)->cbus	|0|
|"0000011011"|	"00000000"|			
| 指令(00000111)|[xx]=|acc	|
|"0000011100"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++|
|"0000011101"|	"01100000"|	dbus->mar|	(mem->cpu)->cbus	|++|
|"0000011110"|	"01010000"|	mar->abus|	(mem->cpu)->cbus	|++|
|"0000011111"|	"10001000"|	acc->dbus|	(cpu->mem)->cbus	|++|
|"0000100000"|	"11110011"|	PC++	|(mem->cpu)->cbus	|0|
|"0000100001"|	"01100000"|			
| "0000100010"|	"01011000"|	
| "0000100011"|	"10000000"|	
| 指令(00001001)|reg0=acc|	
|"0000100100"|	"10010011"|	acc->reg|	reg0	| 0 |
|"0000100101"|	"00000000"|			
| "0000100110"|	"00000000"|			
| "0000100111"|	"10000000"|			
| 指令(00001010)|reg1=acc|	
|"0000101000"|	"10010111"|	acc->reg|	reg1	| 0 |
|"0000101001"|	"00000000"|			
| "0000101010"|	"00000000"|			
| "0000101011"|	"10000000"|			
| 指令(00001011)|reg1++	|
|"0000101100"|	"10100100"|	reg->acc|	reg1	|++|
|"0000101101"|	"00110000"|	ACC++	|(mem->cpu)->cbus	|++|
|"0000101110"|	"10010111"|	acc->reg|	reg1	|0|
|"0000101111"|	"10000000"|			
| 指令(00001100)|acc=reg0%reg1	|
|"0000110000"|	"10110011"|	acc=reg|0%reg1		|0|
|"0000110001"|	"00110000"|			
| "0000110010"|	"10010111"|			
| "0000110011"|	"10000000"|			
| 指令(00001101)|jmpif(acc==0)	|
|"0000110100"|	"00100001"|	null		| reg1 | conditionjmp |
|"0000110101"|	"11110011"|	PC++	 | reg1	| 0 |
|"0000110110"|	"00000000"|			
| "0000110111"|	"00000000"|			
| "0000111000"|	"00000000"|	pc->abus|	(mem->cpu)->cbus	|++|
|"0000111001"|	"00010000"|	dbus->IR|	(mem->cpu)->cbus	|++|
|"0000111010"|	"01110011"|	IR->PC|	(mem->cpu)->cbus	|0|
|"0000111011"|	"00000000"|			
| 指令(00001111)|acc=reg0-reg1	|
|"0000111100"|	"10110011"|	acc=reg0-reg1	|(mem->cpu)->cbus	|0|
|"0000111101"|	"00000000"|			
| "0000111110"|	"00000000"|			
| "0000111111"|	"00000000"|			
| 指令(00010000)|acc=reg2|	
|"0001000000"|	"10101011"|	acc=reg2|	(mem->cpu)->cbus	|0|
|"0001000001"|	"00000000"|			
| "0001000010"|	"00000000"|			
| "0001000011"|	"00000000"|			
| 指令(00010001)|reg2+=reg1|	
|"0001000100"|	"10100100"|	acc=reg1|	(mem->cpu)->cbus	|0|
|"0001000101"|	"11001011"|	reg2+=acc|	(mem->cpu)->cbus	|0|
|"0001000110"|	"00000000"|			
| "0001000111"|	"00000000"|			
| 指令(00010010)|reg2=acc|	
|"0001001000"|	"10011011"|	acc->reg|	reg2	|0|
|"0001001001"|	"00000000"|			
| "0001001010"|	"00000000"|		
| "0001001011"|	"00000000"|	
### 指令集合

| 二进制码 | 指令含义 |
| :---: | :---: |
| 00000001 |	acc++  |
| 00000010  xxxxxxxx |	acc = xx  |
| 00000011 |	acc = io  |
| 00000100  xxxxxxxx |	acc = mem[xx]  |
| 00000110  xxxxxxxx | 	jmp xx  |
| 00000111  xxxxxxxx |	[xx] <= acc   |
| 00001001 |	reg0 = acc  |
| 00001010 | 	reg1 = acc  |
| 00001011 |	reg1 ++  |
| 00001101  xxxxxxxx |	jz xx if(acc==0)   |
| 00001111 |	acc=reg0-reg1  |
| 00010000 |	acc=reg2  |
| 00010001 |	reg2+=reg1  |
| 00010010 |	reg3=acc  |

## 仿真

仿真采用一段程序进行仿真，程序的流程是从IO读入一个数n(仿真中为10，0x0a,"0000 1010”)，计算0+1+2+・・・+(n-1)的和，并存入主存的某地址内。程序不是最简单的写法但是基本可以覆盖设计的指令集合。

#### 程序
| 机器码 | 汇编代码 |
| :---: | :---: |
| 00000011 | acc = io						|
| 00001001 |reg0 = acc						|
| 00000010 | acc = 0						|
| 00000000 |   								|
| 00001010 |reg1 = acc						|
| 00010010 |reg3 = acc						|
| 00001111 |  L0:acc=reg0-reg1				|
| 00001101 |  jz L if(acc==0) 				|
| 00001101 |    							|
| 00010001 |reg2+=reg1						|
| 00001011 |reg1 ++							|
| 00000110 | jmp L0							|
| 00000110 |   								|
| 00010000 |   L: acc=reg2					|
| 00000111 |   [xx] acc						|
| 10000001 |								|

#### 仿真波形及解释

![图5 仿真波形](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/1.png?raw=true)

仿真开始，CPU先执行0位置微指令从内存取指令，解释成微指令地址跳转。第一条完成从io取数据。之后完成对寄存器的置位，完成从内存取立即数并对寄存器赋初值。图5仿真结束位置已经对两个寄存器赋了初值。

![图6 仿真波形](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/2.png?raw=true)

赋初值完成后利用reg0-2求和。每次循环之中利用acc=reg0-reg1判断跳转条件，由于reg1还未达到reg0的值故acc不为零，zy为0，故循环继续。图7为仿真交后部分循环中波形。

![图7 仿真波形](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/6.png?raw=true)
![图8 仿真波形](https://github.com/liu946/MicroInstructionsCPU/blob/master/res/7.png?raw=true)

仿真的最后reg1与reg0相等，相减acc=0,zy在此图开始前被置为1，循环退出，之后取出reg2中的和到acc之后将其送入主存，此处（1234ns）显示的是和45（00101101）在数据总线上传送的过程，cpudbus=45。


## CPU模式的对比和探讨

CPU实现方式常用的有两种，一种是组合逻辑实现，一种即为此次试验实现的微程序方式。

#### 组合逻辑	

组合逻辑控制器是采用组合逻辑技术来实现控制操作，把控制部件看成是产生专门固定时序控制信号的逻辑电路，这种逻辑电路是由门电路和触发器构成的复杂逻辑网络。 

1. 采用组合逻辑设计方法设计控制单元，微操作控制部件的线路结构十分庞杂，不规整。
2. 指令系统功能越全，微操作命令越多，线路就越复杂。
3. 一旦控制部件构成后，除非重新设计和物理上对它重新布线，否则要想增加新的控制功能是不可能的。
4. 组合逻辑控制的最大优点是速度较快。

#### 微程序逻辑

微程序控制器是为了克服组合逻辑控制器线路复杂、不易修改的缺点而提出的，用类似存储程序的办法，来解决微操作命令序列的形成。就是把一条机器指令看成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作。然后把这些微程序存到一个存储器中，用寻找用户程序机器指令的办法来寻找每个微程序中的微指令，逐条执行每一条微指令，也就相应地完成了一条机器指令的全部操作。

1. 具有设计规整、调试、维修以及更改、扩充指令方便的优点
2. 微程序逻辑易于实现自动化设计。
3. 使用了控制存储器，所以指令的执行速度比组合逻辑控制器慢。

## 感想与体会

1. 合理分配同步与异步逻辑

	对于结构简单，无需置位的原件，可以使用异步逻辑，这种方法可以保证其在时钟空闲时间准备好数据。取数据时注意数据的稳定性，不能在数据改变的时钟上取数据，这样得到的结果是不确定的。

2. 三态门的合理使用

	合理的使用三态门可以简化电路，提高可扩展性。使用三态门时应该注意，在三态门系统中只有一个数据源可以设置数据，其他的门都要保持高阻状态，这样才能合理的使用

3. VHDL语言逻辑

	在VHDL语言设计中，有一些地方值得注意。在process语法块中语句使用串行模式运行，但是并不意味着可以用此设计迭代过程，所有左值变量都是在退出语句块的时候改变的，这意味着每次process中的被改变的变量都是无法在本次使用新值的。遇到此问题需要合理设计使得类似动作能够分散在不同时钟下进行。

4. 合理利用互斥结构

	本系统总线控制和内部通用寄存器选择设置为互斥逻辑，可以使用同样的几位控制字表示。

5. 计算机设计是各方面的配合和妥协的结果

	通过微程序实现方式和组合逻辑实现方式的比较，我们不难发现，设计简单精巧往往需要在另一方面，比如效率，上面的牺牲而好的硬件设计就是在这各种牺牲和优势之间的一种平衡。